version: '3'

tasks:
  pull-images:
    desc: Pull required Docker images
    cmds:
      - docker pull postgres:15
      - docker pull node:18-alpine
      - docker pull nginx:alpine
      - docker pull python:3.11-slim

  launch:
    desc: Launch the application in specified environment (prod or dev)
    cmds:
      - task: pull-images
      - echo "Starting Cat Weight Tracker in {{.ENV}} mode..."
      - |
        if [ "{{.ENV}}" = "dev" ]; then
          # For dev, only start the services that are needed
          docker-compose -f docker-compose.dev.yml up --build -d
        else
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up --build -d
        fi
      - sleep 5
      - echo "Application started in {{.ENV}} mode"
      - |
        if [ "{{.ENV}}" = "dev" ]; then
          echo "- Frontend: http://localhost:3000"
        else
          echo "- Frontend: http://localhost:80"
        fi
        echo "- Backend API: http://localhost:4000"
    vars:
      ENV: '{{.ENV | default "prod"}}'

  stop:
    desc: Stop the application in specified environment
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} down
    vars:
      ENV: '{{.ENV | default "prod"}}'

  logs:
    desc: Show logs for all or specific service
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} logs {{.SERVICE}} {{.FOLLOW}}
    vars:
      ENV: '{{.ENV | default "prod"}}'
      SERVICE: '{{.SERVICE | default ""}}'
      FOLLOW: '{{if .FOLLOW}}-f{{end}}'

  lint:
    desc: Run linting checks
    cmds:
      - echo "Running frontend linting..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm run lint
      - echo "Running backend linting..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend flake8
    vars:
      ENV: '{{.ENV | default "prod"}}'

  lint-fix:
    desc: Run linting and fix issues automatically where possible
    cmds:
      - echo "Running frontend linting with auto-fix..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm run lint -- --fix
    vars:
      ENV: '{{.ENV | default "prod"}}'

  test:
    desc: Run all tests
    cmds:
      - echo "Running all tests..."
      - task: test-frontend
      - task: test-backend
    vars:
      ENV: '{{.ENV | default "prod"}}'

  test-frontend:
    desc: Run frontend tests
    cmds:
      - echo "Running frontend tests..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm test -- --watchAll=false
    vars:
      ENV: '{{.ENV | default "prod"}}'

  test-backend:
    desc: Run backend tests
    cmds:
      - echo "Running backend tests..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend pytest {{.ARGS}}
    vars:
      ENV: '{{.ENV | default "prod"}}'
      ARGS: '{{.ARGS | default ""}}'

  db:
    desc: Database operations (migrate, reset)
    cmds:
      - |
        if [ "{{.OP}}" = "migrate" ]; then
          echo "Running database migrations..."
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend alembic upgrade head
        elif [ "{{.OP}}" = "reset" ]; then
          echo "Resetting database..."
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} down -v
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up -d db
          sleep 5
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend alembic upgrade head
        else
          echo "Unknown operation - {{.OP}}"
          echo "Available operations - migrate, reset"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'
      OP: '{{.OP | default "migrate"}}'

  shell:
    desc: Open a shell in a service container
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec {{.SERVICE}} sh
    vars:
      ENV: '{{.ENV | default "prod"}}'
      SERVICE: '{{.SERVICE | default "backend"}}'
      
  backup:
    desc: Backup the database to a local file
    cmds:
      - |
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        BACKUP_DIR="./backups"
        mkdir -p $BACKUP_DIR
        BACKUP_FILE="${BACKUP_DIR}/cat_weight_tracker_${TIMESTAMP}.sql"
        
        echo "Creating database backup to ${BACKUP_FILE}..."
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db pg_dump -U postgres cat_weight_tracker > "${BACKUP_FILE}"
        
        if [ $? -eq 0 ]; then
          echo "✅ Backup completed successfully!"
          echo "Backup saved to - ${BACKUP_FILE}"
          echo "To restore this backup, run: task restore BACKUP=${BACKUP_FILE}"
        else
          echo "❌ Backup failed!"
          rm -f "${BACKUP_FILE}"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'

  restore:
    desc: Restore the database from a backup file
    cmds:
      - |
        if [ -z "{{.BACKUP}}" ]; then
          echo "❌ Error - No backup file specified!"
          echo "Usage: task restore BACKUP=./backups/filename.sql"
          exit 1
        fi
        
        if [ ! -f "{{.BACKUP}}" ]; then
          echo "❌ Error - Backup file not found - {{.BACKUP}}"
          exit 1
        fi
        
        echo "⚠️  WARNING - This will overwrite the current database!"
        echo "Are you sure you want to restore from {{.BACKUP}}? (y/n)"
        read -r confirm
        
        if [ "$confirm" != "y" ]; then
          echo "Restore cancelled."
          exit 0
        fi
        
        echo "Restoring database from {{.BACKUP}}..."
        
        # Make sure the database is running
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up -d db
        sleep 5
        
        # Drop and recreate the database
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -c "DROP DATABASE IF EXISTS cat_weight_tracker;"
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -c "CREATE DATABASE cat_weight_tracker;"
        
        # Restore from backup
        cat "{{.BACKUP}}" | docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -d cat_weight_tracker
        
        if [ $? -eq 0 ]; then
          echo "✅ Restore completed successfully!"
        else
          echo "❌ Restore failed!"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'
      BACKUP: '{{.BACKUP}}'
      
  release:
    desc: Create a new release with automated semantic versioning
    cmds:
      - |
        # Get current version from package.json
        CURRENT_VERSION=$(grep '"version":' package.json | cut -d'"' -f4)
        echo "Current version: v$CURRENT_VERSION"
        
        # Determine bump type based on commit messages
        determine_bump_type() {
          # Get all commits since the last tag
          local commits=$(git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:"%s")
          
          # Check for breaking changes or feat commits
          if echo "$commits" | grep -q "BREAKING CHANGE" || echo "$commits" | grep -q "!:"; then
            echo "major"
          elif echo "$commits" | grep -q "^feat"; then
            echo "minor"
          else
            echo "patch"
          fi
        }
        
        # If type is provided, use it; otherwise determine automatically
        if [ -n "{{.TYPE}}" ]; then
          BUMP_TYPE="{{.TYPE}}"
        else
          BUMP_TYPE=$(determine_bump_type)
          echo "Detected change type: $BUMP_TYPE"
        fi
        
        # Parse current version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        
        # Calculate new version
        case $BUMP_TYPE in
          major)
            NEW_VERSION="$((MAJOR + 1)).0.0"
            ;;
          minor)
            NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
            ;;
          patch|*)
            NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
            ;;
        esac
        
        echo "New version: v$NEW_VERSION"
        
        # Update version in package.json
        sed -i.bak "s/\"version\": \"$CURRENT_VERSION\"/\"version\": \"$NEW_VERSION\"/" package.json
        rm package.json.bak
        
        # Generate changelog entry
        DATE=$(date +%Y-%m-%d)
        TEMP_FILE=$(mktemp)
        
        # Write header to temp file
        echo "# Changelog" > $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "All notable changes to this project will be documented in this file." >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> $TEMP_FILE
        echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        
        # Add new version section
        echo "## [v$NEW_VERSION] - $DATE" >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        
        # Add features
        FEATURES=$(git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:"%s" | grep "^feat" | sed 's/feat: /- /' | sed 's/feat(\([^)]*\)): /- /')
        if [ ! -z "$FEATURES" ]; then
          echo "### Features" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
          echo "$FEATURES" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
        fi
        
        # Add fixes
        FIXES=$(git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:"%s" | grep "^fix" | sed 's/fix: /- /' | sed 's/fix(\([^)]*\)): /- /')
        if [ ! -z "$FIXES" ]; then
          echo "### Bug Fixes" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
          echo "$FIXES" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
        fi
        
        # Add other changes
        OTHER=$(git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:"%s" | grep -v "^feat" | grep -v "^fix" | grep -v "^docs" | grep -v "^chore" | grep -v "^test" | grep -v "^ci" | grep -v "^style" | grep -v "^refactor" | sed 's/^/- /')
        if [ ! -z "$OTHER" ]; then
          echo "### Other Changes" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
          echo "$OTHER" >> $TEMP_FILE
          echo "" >> $TEMP_FILE
        fi
        
        # Read existing changelog
        if [ -f "CHANGELOG.md" ]; then
          tail -n +2 "CHANGELOG.md" >> $TEMP_FILE
        fi
        
        # Replace changelog
        mv $TEMP_FILE CHANGELOG.md
        
        # Commit changes
        git add package.json CHANGELOG.md
        git commit -m "chore: bump version to v$NEW_VERSION"
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        
        echo "✅ Version bumped to v$NEW_VERSION"
        echo "To push changes and tag, run: git push && git push --tags"
    vars:
      TYPE: '{{.TYPE | default ""}}'
      
  build-images:
    desc: Build Docker images locally
    cmds:
      - docker build -t ghcr.io/yourusername/cat-weight-tracker-backend:latest ./backend
      - docker build -t ghcr.io/yourusername/cat-weight-tracker-frontend:latest ./frontend
      
  push-images:
    desc: Push Docker images to GitHub Container Registry
    cmds:
      - echo "Pushing images to GitHub Container Registry..."
      - docker push ghcr.io/yourusername/cat-weight-tracker-backend:latest
      - docker push ghcr.io/yourusername/cat-weight-tracker-frontend:latest
      
  k8s-apply:
    desc: Apply Kubernetes manifests using kubectl
    cmds:
      - kubectl apply -k k8s/overlays/prod
      
  argocd-deploy:
    desc: Deploy the application using ArgoCD
    cmds:
      - kubectl apply -f k8s/argocd-app.yaml

  # MCP server tasks
  mcp-pull-images:
    desc: Pull required Docker images for MCP servers
    cmds:
      - docker pull postgres:13
      - docker pull atlassian/jira-software:9.4
      - echo "Note - GitHub Enterprise image requires authentication. Skipping pull."

  mcp-start:
    desc: Start MCP servers (jira, github, or all)
    cmds:
      - task: mcp-pull-images
      - |
        if [ "{{.SERVER}}" = "all" ] || [ "{{.SERVER}}" = "jira" ] || [ -z "{{.SERVER}}" ]; then
          echo "Starting Jira MCP server..."
          docker-compose -f docker-compose.jira.yml up -d
          echo "Jira is starting up at http://localhost:9000"
        fi
        
        if [ "{{.SERVER}}" = "all" ] || [ "{{.SERVER}}" = "github" ]; then
          echo "Starting GitHub MCP server..."
          docker-compose -f docker-compose.github.yml up -d
          echo "GitHub is starting up at http://localhost:9001"
          echo "Note - You'll need to replace the placeholder license key in docker-compose.github.yml"
        fi
        
        echo "MCP servers are starting. They may take a few minutes to be fully available."
    vars:
      SERVER: '{{.SERVER | default "all"}}'

  mcp-stop:
    desc: Stop MCP servers (jira, github, or all)
    cmds:
      - |
        if [ "{{.SERVER}}" = "all" ] || [ "{{.SERVER}}" = "jira" ] || [ -z "{{.SERVER}}" ]; then
          echo "Stopping Jira MCP server..."
          docker-compose -f docker-compose.jira.yml down
        fi
        
        if [ "{{.SERVER}}" = "all" ] || [ "{{.SERVER}}" = "github" ]; then
          echo "Stopping GitHub MCP server..."
          docker-compose -f docker-compose.github.yml down
        fi
        
        echo "MCP servers have been stopped."
        echo "Your data is preserved in Docker volumes."
    vars:
      SERVER: '{{.SERVER | default "all"}}'

  mcp-status:
    desc: Check status of MCP servers
    cmds:
      - |
        echo "Checking MCP server status..."
        echo "Jira server -"
        docker ps --filter "name=jira-server" --format "{% raw %}{{.Names}}: {{.Status}}{% endraw %}"
        echo "GitHub server -"
        docker ps --filter "name=github-server" --format "{% raw %}{{.Names}}: {{.Status}}{% endraw %}"