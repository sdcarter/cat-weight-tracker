version: '3'

tasks:
  pull-images:
    desc: Pull required Docker images
    cmds:
      - docker pull postgres:15
      - docker pull node:18-alpine
      - docker pull nginx:alpine
      - docker pull python:3.11-slim

  launch:
    desc: Launch the application in specified environment (prod or dev)
    cmds:
      - task: pull-images
      - echo "Starting Cat Weight Tracker in {{.ENV}} mode..."
      - |
        if [ "{{.ENV}}" = "dev" ]; then
          # For dev, only start the services that are needed
          docker-compose -f docker-compose.dev.yml up --build -d
        else
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up --build -d
        fi
      - sleep 5
      - echo "Application started in {{.ENV}} mode"
      - |
        if [ "{{.ENV}}" = "dev" ]; then
          echo "- Frontend: http://localhost:3000"
        else
          echo "- Frontend: http://localhost:80"
        fi
        echo "- Backend API: http://localhost:4000"
    vars:
      ENV: '{{.ENV | default "prod"}}'

  stop:
    desc: Stop the application in specified environment
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} down
    vars:
      ENV: '{{.ENV | default "prod"}}'

  logs:
    desc: Show logs for all or specific service
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} logs {{.SERVICE}} {{.FOLLOW}}
    vars:
      ENV: '{{.ENV | default "prod"}}'
      SERVICE: '{{.SERVICE | default ""}}'
      FOLLOW: '{{if .FOLLOW}}-f{{end}}'

  lint:
    desc: Run linting checks
    cmds:
      - echo "Running frontend linting..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm run lint
      - echo "Running backend linting..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend flake8
    vars:
      ENV: '{{.ENV | default "prod"}}'

  lint-fix:
    desc: Run linting and fix issues automatically where possible
    cmds:
      - echo "Running frontend linting with auto-fix..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm run lint -- --fix
    vars:
      ENV: '{{.ENV | default "prod"}}'

  test:
    desc: Run tests
    cmds:
      - echo "Running frontend tests..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm frontend npm test -- --watchAll=false
      - echo "Running backend tests..."
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend pytest
    vars:
      ENV: '{{.ENV | default "prod"}}'

  db:
    desc: Database operations (migrate, reset)
    cmds:
      - |
        if [ "{{.OP}}" = "migrate" ]; then
          echo "Running database migrations..."
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend alembic upgrade head
        elif [ "{{.OP}}" = "reset" ]; then
          echo "Resetting database..."
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} down -v
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up -d db
          sleep 5
          docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} run --rm backend alembic upgrade head
        else
          echo "Unknown operation: {{.OP}}"
          echo "Available operations: migrate, reset"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'
      OP: '{{.OP | default "migrate"}}'

  shell:
    desc: Open a shell in a service container
    cmds:
      - docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec {{.SERVICE}} sh
    vars:
      ENV: '{{.ENV | default "prod"}}'
      SERVICE: '{{.SERVICE | default "backend"}}'
      
  backup:
    desc: Backup the database to a local file
    cmds:
      - |
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        BACKUP_DIR="./backups"
        mkdir -p $BACKUP_DIR
        BACKUP_FILE="${BACKUP_DIR}/cat_weight_tracker_${TIMESTAMP}.sql"
        
        echo "Creating database backup to ${BACKUP_FILE}..."
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db pg_dump -U postgres cat_weight_tracker > "${BACKUP_FILE}"
        
        if [ $? -eq 0 ]; then
          echo "✅ Backup completed successfully!"
          echo "Backup saved to: ${BACKUP_FILE}"
          echo "To restore this backup, run: task restore BACKUP=${BACKUP_FILE}"
        else
          echo "❌ Backup failed!"
          rm -f "${BACKUP_FILE}"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'

  restore:
    desc: Restore the database from a backup file
    cmds:
      - |
        if [ -z "{{.BACKUP}}" ]; then
          echo "❌ Error: No backup file specified!"
          echo "Usage: task restore BACKUP=./backups/filename.sql"
          exit 1
        fi
        
        if [ ! -f "{{.BACKUP}}" ]; then
          echo "❌ Error: Backup file not found: {{.BACKUP}}"
          exit 1
        fi
        
        echo "⚠️  WARNING: This will overwrite the current database!"
        echo "Are you sure you want to restore from {{.BACKUP}}? (y/n)"
        read -r confirm
        
        if [ "$confirm" != "y" ]; then
          echo "Restore cancelled."
          exit 0
        fi
        
        echo "Restoring database from {{.BACKUP}}..."
        
        # Make sure the database is running
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} up -d db
        sleep 5
        
        # Drop and recreate the database
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -c "DROP DATABASE IF EXISTS cat_weight_tracker;"
        docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -c "CREATE DATABASE cat_weight_tracker;"
        
        # Restore from backup
        cat "{{.BACKUP}}" | docker-compose {{if eq .ENV "dev"}}-f docker-compose.dev.yml{{end}} exec -T db psql -U postgres -d cat_weight_tracker
        
        if [ $? -eq 0 ]; then
          echo "✅ Restore completed successfully!"
        else
          echo "❌ Restore failed!"
        fi
    vars:
      ENV: '{{.ENV | default "prod"}}'
      BACKUP: '{{.BACKUP}}'
      
  release:
    desc: Create a new release with semantic versioning
    cmds:
      - |
        CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Current version: $CURRENT_VERSION"
        
        if [ "{{.TYPE}}" = "" ]; then
          echo "Release type options: patch, minor, major"
          echo "Usage: task release TYPE=patch|minor|major MESSAGE='Your release message'"
          exit 1
        fi
        
        # Remove 'v' prefix for version calculation
        VERSION_NUM=${CURRENT_VERSION#v}
        IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
        
        case {{.TYPE}} in
          patch)
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
            ;;
          minor)
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="v$MAJOR.$NEW_MINOR.0"
            ;;
          major)
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="v$NEW_MAJOR.0.0"
            ;;
          *)
            echo "Invalid release type: {{.TYPE}}. Use: patch, minor, or major"
            exit 1
            ;;
        esac
        
        # Default message if none provided
        MESSAGE="{{.MESSAGE}}"
        if [ -z "$MESSAGE" ]; then
          MESSAGE="Release $NEW_VERSION"
        fi
        
        # Update CHANGELOG.md
        DATE=$(date +%Y-%m-%d)
        echo "Updating CHANGELOG.md..."
        
        # Create a temporary file
        TEMP_FILE=$(mktemp)
        
        # Write the new version header and message to the temp file
        echo "# Changelog" > $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "All notable changes to this project will be documented in this file." >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> $TEMP_FILE
        echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "## [$NEW_VERSION] - $DATE" >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        echo "### Changed" >> $TEMP_FILE
        echo "- $MESSAGE" >> $TEMP_FILE
        echo "" >> $TEMP_FILE
        
        # Append the existing content after the first line
        tail -n +7 CHANGELOG.md >> $TEMP_FILE
        
        # Replace the original file with the temp file
        mv $TEMP_FILE CHANGELOG.md
        
        # Commit the CHANGELOG update
        git add CHANGELOG.md
        git commit -m "Update CHANGELOG for $NEW_VERSION"
        
        # Create the tag
        echo "Creating new release: $NEW_VERSION"
        git tag -a $NEW_VERSION -m "$MESSAGE"
        
        echo "Tag created. To push changes and tag to remote, run:"
        echo "git push && git push origin $NEW_VERSION"
    vars:
      TYPE: '{{.TYPE}}'
      MESSAGE: '{{.MESSAGE}}'
      
  dev-clean:
    desc: Clean development environment (remove containers, volumes, and node_modules)
    cmds:
      - echo "Stopping development containers..."
      - docker-compose -f docker-compose.dev.yml down -v
      - echo "Removing frontend node_modules volume..."
      - docker volume rm diet_frontend_node_modules || true
      - echo "Development environment cleaned successfully!"